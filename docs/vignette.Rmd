---
title: "R package: magicdesign"
output: html_document
---

## Introduction {#S1}
The idea behind the use of Multiparental Advanced Generation Inter-Cross (MAGIC) population in crops was introduced in [Mackay and Powell (2007)](https://doi.org/10.1016/j.tplants.2006.12.001). Subsequently, [Cavanagh et al (2008)](https://doi.org/10.1016/j.pbi.2008.01.002) further refined the idea and provided an example for an 8-founder MAGIC population. Over the years, many MAGIC populations have been developed for various numbers of founders in different crops. Recent reviews from [Scott et al (2020)](https://doi.org/10.1038/s41437-020-0336-6) and [Arrones et al (2020)](https://doi.org/10.3390/biology9080229) provide good details on the history of MAGIC population development.  

A major advantage of using a MAGIC population in crops is that the recombinant inbred lines (RILs) have highly recombined genomes with diverse mosaics of the founders. As such, MAGIC population is great for QTL mapping and breeding owing to its high mapping resolution and presence of various novel haplotypes. While MAGIC population is a great genetic resource, the design of crossing schemes can be daunting especially in a population with large number of founders. Many of the MAGIC populations to date have been centered around 8 founders. Based on the information in Table 1 of [Scott et al (2020)](https://doi.org/10.1038/s41437-020-0336-6), 8-founder MAGIC populations constitute 15 of 28 total MAGIC populations. Of these 15 MAGIC populations, only one was created from a full design and the remaining were created from either partial or basic designs. Further information on the design types can be found in the [Details](#S5) Section.  

A MAGIC population is usually represented by one or more funnels. A **funnel** is a pedigree subset where it has all the steps in getting all the `n` founders going into a RIL. In the example shown below, there are four founders and three funnels. Each funnel has a unique crossing scheme. The first round of crossing involves `1 x 2`, `3 x 4`, `1 x 3`, and so on. These are known as **two-way crosses** because the genomes of the crosses progeny are made of two founders. The next round of crossing involves `(1 x 2) x (3 x 4)`, `(1 x 3) x (2 x 4)` and `(1 x 4) x (2 x 3)`. These are known as **four-way crosses** because the genomes of the crosses progeny are made of four founders. Same concept applies for `n`-founders in which the last step involves **n-way crosses**. For example, `n=16` would have two-way, four-way, eight-way and sixteen-way crosses. In general, because the number of individuals in each funnel halves at each generation, it is convenient to have `n` as a power of 2 (e.g. 4, 8, 16, 32, ...). It is also possible to accommodate other `n`, and these will all be discussed in the [Details](#S5) section.  

```{r echo=F, fig.width=10, fig.height=3}
m <- data.frame(x=c(1, 2, 3, 4, 1.5, 3.5, 2.5,
                    1, 2, 3, 4, 1.5, 3.5, 2.5,
                    1, 2, 3, 4, 1.5, 3.5, 2.5),
                y=c(5, 5, 5, 5, 3, 3, 1,
                    5, 5, 5, 5, 3, 3, 1,
                    5, 5, 5, 5, 3, 3, 1),
                label=c("1", "2", "3", "4", "12", "34", "1234",
                        "1", "2", "3", "4", "13", "24", "1324",
                        "1", "2", "3", "4", "14", "23", "1423"),
                funnel=c(rep("funnel 1",7), rep("funnel 2",7), rep("funnel 3",7)))
m.arrow <- data.frame(x1=c(1, 2, 3, 4, 1.5, 3.5,
                           1, 2, 3, 4, 1.5, 3.5,
                           1, 2, 3, 4, 1.5, 3.5),
                      x2=c(1.5, 1.5, 3.5, 3.5, 2.5, 2.5,
                           1.5, 3.5, 1.5, 3.5, 2.5, 2.5,
                           1.5, 3.5, 3.5, 1.5, 2.5, 2.5),
                      y1=c(4.8, 4.8, 4.8, 4.8, 2.8, 2.8,
                           4.8, 4.8, 4.8, 4.8, 2.8, 2.8,
                           4.8, 4.8, 4.8, 4.8, 2.8, 2.8),
                      y2=c(3.2, 3.2, 3.2, 3.2, 1.2, 1.2,
                           3.2, 3.2, 3.2, 3.2, 1.2, 1.2,
                           3.2, 3.2, 3.2, 3.2, 1.2, 1.2),
                      funnel=c(rep("funnel 1",6), rep("funnel 2",6), rep("funnel 3",6)))
ggplot2::ggplot() +
  ggplot2::geom_text(data=m, ggplot2::aes(x=x, y=y, label=label), size=5) +
  ggplot2::geom_segment(data=m.arrow, ggplot2::aes(x=x1, xend=x2, y=y1, yend=y2), color="#AAAAAA") +
  ggplot2::facet_wrap(ggplot2::vars(funnel), nrow=1) +
  ggplot2::annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, fill=NA, color="#DDDDDD") +
  ggplot2::theme(strip.text=ggplot2::element_text(hjust=0, size=15)) +
  ggplot2::theme(panel.grid=ggplot2::element_blank()) +
  ggplot2::theme(panel.background=ggplot2::element_blank()) +
  ggplot2::theme(axis.title=ggplot2::element_blank()) +
  ggplot2::theme(axis.text=ggplot2::element_blank()) +
  ggplot2::theme(axis.ticks=ggplot2::element_blank()) +
  ggplot2::theme(strip.background=ggplot2::element_blank())
```


With many designs available, it is best to plan ahead since the population creation process can be highly laborious. Prior to this, there was not any available tool for researchers to create and test various MAGIC population designs, which motivates us to create this `magicdesign` package.  

&nbsp;  

## Package Implementation {#S2}
This `magicdesign` package is available in three options:  
1. R package  
2. R Shiny app (web)  
3. R Shiny app (local)  

The first option is targeted for `R` users. The second option is provided for non-`R` users with its web-based `Shiny` interface. The third option is somewhere in between the other two options, where it requires the users to run the `Shiny` interface locally. Instructions for each option are provided in the following section.  

&nbsp;  

## Installation {#S3}
### R package {#S3.1}
Unlike many common [CRAN](https://cran.r-project.org/) `R` packages, `magicdesign` is provided directly from [GitHub](https://github.com/cjyang-sruc/magicdesign). To install an `R` package from GitHub, we first need to install the `devtools` package if we do not already have it installed.  

```{r eval=F}
install.packages("devtools")
```

Next, we will need to use `devtools` to install `magicdesign`. Note that this step may ask for various updates. **The easiest way is to just ignore the updates**. Updating other packages is usually not a problem when installing a [CRAN](https://cran.r-project.org/) `R` package, but it can be problematic with `devtools`. In rare occasions, some of these updates might actually be needed for the *dependencies* (`R` packages that `magicdesign` requires). If such issue arises, please update those packages prior to installing `magicdesign`.  

```{r eval=F}
devtools::install_github("cjyang-sruc/magicdesign")
```

*Additional notes*: The *dependencies* for `magicdesign` are: `gtools`, `stringr`, `blocksdesign`, `AlphaSimR`, `ggplot2`, `reshape2`, `ggrepel`, `plotly` and `htmlwidgets`. These packages should be installed automatically with `magicdesign`. Installing a package using `devtools` may result in a warning message about `Rtools`. Please ignore it since we do not need `Rtools` here. That should be fine, I think.  

&nbsp;  

### R Shiny app (web) {#S3.2}
The `Shiny` app is available at <https://www.shinyapps.io/>. It provides the latest version of `magicdesign` in a web-based interface for users without needing to work with `R` directly. It is especially useful for users who are not familiar with `R` and also users whom currently do not have access to a working computer. Unfortunately, we do not have any funding to maintain a `Shiny` app server, so our web-based interface is limited to 24 free hours per month courtesy of `Rstudio`. Please consider using the other two options if possible.  

&nbsp;  

### R Shiny app (local) {#S3.3}
Work under progress...  

&nbsp;  



## Workflow {#S4}
A rough approximation of what a user can do with `magicdesign` is shown in the figure below.  

```{r echo=F, fig.width=10}
wf <- data.frame(x=c(1,1,1,1,5,8,1,1),
                 y=c(11,9,7,5,7,7,3,1),
                 label=c("Create a MAGIC population crossing scheme",
                         "Simulate the population",
                         "Evaluate recombinants within an interval",
                         "Evaluate genome-wide founder distributions",
                         "Repeat for n.sim-times",
                         "Test another crossing schemes",
                         "Display the results (up to 6 schemes)",
                         "Decide on your choice(s) of crossing scheme"))

wf.arrow <- data.frame(x1=c(1,1,1,1,1),
                       x2=c(1,1,1,1,1),
                       y1=c(10.5, 8.5, 6.5, 4.5, 2.5),
                       y2=c(9.5, 7.5, 5.5, 3.5, 1.5))

ggplot2::ggplot() +
  ggplot2::geom_label(data=wf, ggplot2::aes(x=x, y=y, label=label),
                      fill=c("#FFF0F0","#F0FFF0","#F0FFF0","#F0FFF0","#F0FFF0","#FFF0F0","#F0F0FF","#F0F0FF"),
                      label.padding=ggplot2::unit(0.5, "lines")) +
  ggplot2::geom_segment(data=wf.arrow, ggplot2::aes(x=x1, xend=x2, y=y1, yend=y2),            
                        arrow=ggplot2::arrow(length=ggplot2::unit(0.01,"npc"))) +
  ggplot2::annotate("segment", x=c(3.5, 3.5, 3.8), xend=c(3.8, 3.8, 3.8), y=c(9, 5, 9), yend=c(9, 5, 5)) +
  ggplot2::annotate("segment", x=c(1.2, 6.4), xend=c(6.4, 6.4), y=c(4, 4), yend=c(4, 10)) +
  ggplot2::annotate("segment", x=6.4, xend=1.2, y=10, yend=10,
                    arrow=ggplot2::arrow(length=ggplot2::unit(0.01,"npc"))) +
  ggplot2::theme_void() +
  ggplot2::scale_x_continuous(limits=c(-2,10), expand=c(0,0))
```

**Create a MAGIC population crossing scheme**. This step begins with users providing input arguments to the function `magic.eval`, which will determine the type of MAGIC population to create. All supported population types are described in the [Supported Designs](#S5.1). In addition, a flexible option is also provided in the `magic.eval` function where users can supply a complete pedigree. The pedigree must include all individuals used in generating a MAGIC population. Further information on how to use a pedigree input for `magic.eval` is described in [Pedigree](#S5.1.5). Regardless of the options chosen, this step will generate a crossing scheme from the founders to the final RILs.  

**Simulate the population**. This step takes the previously generated crossing scheme and simulate a population of RILs. To keep track of founder alleles, we code them (internally) as shown in the following example with `n=4` inbred founders. Since a biallelic marker in an inbred individual can only be 0 or 2, we need three "markers" at the same genetic position to code for four founder alleles at a single marker. By keeping the genetic positions the same, we can prevent recombination between these "markers" in the simulation so the founder alleles information is preserved in the RILs.  

```{r echo=F}
mat <- matrix(c(0,2,0,0,0,0,2,0,0,0,0,2), nrow=4, ncol=3)
rownames(mat) <- paste("founder ", 1:4, sep="")
colnames(mat) <- c("marker_1a", "marker_1b", "marker_1c")
print(mat)
```

At the end of the simulation, we convert the RIL marker data (internally) into another format based on `n` founder alleles.  

```{r echo=F}
mat <- matrix(c(2,2,3,3,3,1,1,1,1,1,4,4,4,4,2), nrow=3, ncol=5, byrow=T)
rownames(mat) <- paste("RIL ", 1:3, sep="")
colnames(mat) <- paste("marker_", 1:5, sep="")
print(mat)
```

**Evaluate recombinants within an interval**. By default, we count the number of all $n^2 - n$ recombinant haplotypes between two markers at 5 centiMorgans apart in the RILs. This interval can be modified by specifying the `hap.int` in `magic.eval`. A good MAGIC population would ideally have high mean counts of recombinant haplotypes and low variance among all recombinant haplotypes. Further information is provided in [Plot - Interval](#S5.3.2).  

**Evaluate genome-wide founder distributions**. Here, we calculate the proportions of each founder genome in the RILs as well as the number of unique founder alleles in each chromosome. Note that the founder genome proportions are determined from genetic positions. Ideally, a good MAGIC population would have equal proportions of each founder genome in the RILs and high number of unique founder alleles in each chromosome. Further information is provided in [Plot - Whole](#S5.3.3).  

**Repeat for n.sim-times**. The previous three steps are repeated by specifying `n.sim` in `magic.eval`. Typically, `n.sim=100` should be sufficient, I think. Note that the same initial crossing scheme is used in all iterations of the simulations. If only the output pedigree is desired, `n.sim` can be simply set to `1` to speed the process up.  

**Test another crossing schemes**. This is simply a new simulation with different `arguments` in `magic.eval` for users to try a different MAGIC population design.  

**Display the results (up to 6 schemes)**. Once the simulations are done, we can plot the results and compare for up to 6 designs. Too many designs can clutter up the plots, so it is best to keep a low number of designs compared at any time. Besides, we can also plot the pedigree for each design. MAGIC pedigree can be complicated, and so we provide the pedigree as an interactive `html` plot where users can highlight any funnel to identify the paths starting from the founders to RILs. Further information is provided in [Results Visualization](#S5.3).  

**Decide on your choice(s) of crossing scheme**. After we have gone through all the results from different designs, it is now time to make a decision on which to move forward. This is entirely subjective as different users may have different ranks of importance in the genetic characteristics, required labor, available funding, and other factors towards creating a MAGIC population.  

&nbsp;  

## Details {#S5}
This section contains all the information on how to use `magicdesign` split over four sub-sections. We will cover the three required functions and how to specify the arguments in each of them. All the supported designs and modifications are specified in the `magic.eval` function. All the results are displayed using the `magic.ped2plot` and `magic.plot` functions.  

&nbsp;  

### Supported Designs {#S5.1}
Currently, there are four supported MAGIC population designs, namely [Full](#S5.1.1), [Partial](#S5.1.2), [Basic](#S5.1.3) and [Deficient](#S5.1.4). The first three are restricted to `n` number of founders that is of a power of 2 and the last is for `n` that is not a power of 2. Additionally, `magicdesign` also allows custom design via user-input [Pedigree](#S5.1.5). For each design, there are several [Available Modifications](#S5.2). Specifically in the [Partial](#S5.1.2) and [Deficient](#S5.1.4) designs, the `balanced` argument is of important consideration as outlined in [Mod - balanced](#S5.2.4).  

&nbsp;  

#### Full Design {#S5.1.1}
As its name suggests, the full design is the most comprehensive design of all. The full design encompasses all possible founder combinations (funnels), and thus it is always a balanced design (see [Mod - balanced](#S5.2.4) for more information on balanced design). In our simulation, the directions of crosses have no meaning and so `1 x 2` is equivalent to `2 x 1`. But, if both directions are required, please refer to [Mod - reps](#S5.2.1).  

To obtain all possible founder combinations (funnels), we simply need to determine all permutations of $n$ founders in the RILs, and that is $n!$. Since we regard the reciprocal directions of crosses as equivalent, each permutation is equivalent to $2^{n-1}-1$ other permutations. Therefore, we can eliminate those redundant permutations, which leads us to $n!/2^{n-1}$ for a full design. For example, $n=4$ would have $3$ funnels and $n=8$ would have $315$ funnels. Unfortunately, it is impossible in practice to have a full design for $n=16$ or larger as $n=16$ would have $638,512,875$ funnels.  

A full design is only available for `n=4` and `n=8`. To explicitly specify for a full design, we also need to specify the `m` and `balanced` arguments as shown in the table below. Details on `m` can be found in the [Partial](#S5.1.2) section and details on `balanced` can be found in the [Mod - balanced](#5.2.4) section.  

```{r echo=F}
df <- data.frame(n=c(4,8),
                 m=c(1,45),
                 balanced=c("not relevant", TRUE))
df <- kableExtra::kable_styling(kableExtra::kbl(df), bootstrap_options="striped", full_width=F, position="left")
kableExtra::footnote(df, general="if n=4, balanced argument is ignored",
                     footnote_as_chunk=T)
```

#### Partial Design {#S5.1.2}
Unlike the full design, the partial design has a lot more choices to offer. A partial design is simply a subset of a full design, in which the subset can be either balanced or unbalanced. The subset is specified by the argument `m` in `magic.eval`, and the meaning of `m` depends on `balanced=T` or `balanced=F`.  

In the case of `balanced=T`, `m` is the number of partial balanced funnel sets. Each funnel set has $n-1$ funnels. As a corollary, a full design is made of $n!/(2^{n-1}*(n-1))$ unique partial balanced funnel sets. In `n=8`, there are a total of $45$ partial balanced funnel sets. Within a partial balanced funnel set, the founders meet once at two-way crosses, twice at four-way crosses, four times at eight-way crosses, and so on. For example, the following is a partial balanced funnel set for `n=8`.  

Funnel 1: ((1 x 2) x (3 x 8)) x ((4 x 6) x (5 x 7))  
Funnel 2: ((1 x 3) x (4 x 7)) x ((2 x 8) x (5 x 6))  
Funnel 3: ((1 x 4) x (2 x 6)) x ((3 x 7) x (5 x 8))  
Funnel 4: ((1 x 5) x (4 x 8)) x ((2 x 7) x (3 x 6))  
Funnel 5: ((1 x 6) x (3 x 5)) x ((2 x 4) x (7 x 8))  
Funnel 6: ((1 x 7) x (2 x 5)) x ((3 x 4) x (6 x 8))  
Funnel 7: ((1 x 8) x (6 x 7)) x ((2 x 3) x (4 x 5))  

```{r echo=F}
df <- data.frame(founder_pair=do.call(paste, c(data.frame(t(combn(8,2))), sep="-")),
                 two_way=1,
                 four_way=2,
                 eight_way=4)
df <- kableExtra::kable_styling(kableExtra::kbl(df), bootstrap_options="striped", full_width=F, position="left")
kableExtra::scroll_box(df, width= "4in", height="2in")
```

&nbsp;  

In the case of `balanced=F`, `m` is the number of funnels. Since we do not need to keep the design balanced in this setting, we are not restricted by the need to have $n-1$ funnels.  

Note that `n=4` has only one partial balanced set and that is the same as its full design. Although `n=4` can have two partial unbalanced funnels, it has little purpose. To keep things simple, partial design for `n=4` is not provided.  

The arguments required for a partial design are shown in the table below.  

```{r echo=F}
df <- data.frame(n=c(8, 16, 32, 64, 128),
                 min.T=c(1, 1, NA, NA, NA),
                 max.T=c(44, 100, NA, NA, NA),
                 min.F=c(1, 1, 1, 1, 1),
                 max.F=c(315, 10000, 10000, 10000, 10000))
colnames(df) <- c("n", "min", "max", "min", "max")
df <- kableExtra::kable_styling(kableExtra::kbl(df), bootstrap_options="striped", full_width=F, position="left")
df <- kableExtra::add_header_above(df, c("", "balanced=T"=2, "balanced=F"=2))
df <- kableExtra::add_header_above(df, c("", "m"=4))
kableExtra::footnote(df, general="Partial design is not available for n = 32, 64 or 128 when balanced=T",
                     footnote_as_chunk=T)
```


#### Basic Design {#S5.1.3}
The basic design is equivalent to a partial unbalanced design with `m=1` funnel. For example, with 8 founders, the basic design is simply ((1 x 2) x (3 x 4)) x ((5 x 6) x (7 x 8)). Since there is one funnel, high replications of the crosses are usually needed to get the haplotype variations and increase the number of RILs. There is also an option to add an extra generation of crossing among the n-way crosses to further increase haplotype variation. These additional settings are described further in the [Examples](#S6).  

This design is available for n = 4, 8, 16, 32, 64, 128, and it can be used by setting `m=0` for any `n`.  

#### NP2 Design {#S5.1.4}
The Non-Power of 2 (NP2) design is similar to the partial design except that it is meant for `n` that is not a power of 2. The crossing scheme for an NP2 design is based on a `n=2^ceiling(log(n,2))` partial design. For example, ((1 x 2) x (1 x 3)) x ((3 x 5) x (4 x 6)) is a funnel for `n=6` and it has same number of crosses as `n=8` except that founder 1 and 3 are duplicated to fill in the empty slots.  

The NP2 design is available as either balanced or unbalanced, where `m` is the number of funnel sets if `balanced=T` and `m` is the number of funnels if `balanced=F`. Strictly speaking, the balanced NP2 design should only be considered as semi-balanced, as we are only keeping the number of founders in a set balanced but not the crosses. Due to the nature of NP2 design, it requires more than just $n-1$ funnels to keep the crosses balanced. For example, `n=6` requires 3 and 15 funnels to be semi-balanced and fully balanced respectively.  

In addition to partial design, full NP2 design is also available for n = 3, 5, 6, 7 by setting `balanced=T` and m = 1, 48, 285, 135 respectively.

The arguments required for an NP2 design is shown in the table below. Note that the number of funnel (nf) is just provided as a reference and not to be used as an input argument.  

```{r echo=F}
df <- vector()
for(n in c(3,5:7,9:15,17:31,33:63,65:127)){
  n0 <- 2^ceiling(log(n,2))
  nf <- 1
  while(!((nf*n0/n)%%1 == 0)){
    nf <- nf + 1
  }
  df <- rbind(df, c(n, nf))
}

df <- data.frame(df,
                 min.T=c(rep(1, 11), rep(NA, 109)),
                 max.T=c(1, 48, 285, 135, rep(100, 7), rep(NA,109)),
                 min.F=rep(1, 120),
                 max.F=c(1, 240, 855, 945, rep(10000, 116)))
colnames(df) <- c("n", "nf", "min", "max", "min", "max")
df <- kableExtra::kable_styling(kableExtra::kbl(df), bootstrap_options="striped", full_width=F, position="left")
df <- kableExtra::add_header_above(df, c("", "", "balanced=T"=2, "balanced=F"=2))
df <- kableExtra::add_header_above(df, c("", "", "m"=4))
df <- kableExtra::footnote(df, 
                           general="NP2 design is not available for n > 16.",
                           footnote_as_chunk=T)
kableExtra::scroll_box(df, width= "4in", height="3in")
```

#### Pedigree {#S5.1.5}
Instead of using designs from `magicdesign`, we also provide an option for users to input a complete pedigree of their design of choice. Theoretically, this option should work with any design as long as it can represented in a pedigree. The pedigree must be supplied as either a `data.frame` or `matrix` with four columns: individual ID, parent 1 ID, parent 2 ID, and generation number. The founders must be included in the pedigree, in which their individual IDs must be continuous from 1 to n founders, parent IDs as 0 or blank, and generation number as 0. All crosses going from the founders to final RILs including any selfing must be documented in the pedigree, and so the generation number must also be continuous (0 to final generations). The names of the individual IDs do not need to conform to any format as long as they are all unique, and the parent IDs must be present in the individual IDs from previous generations except for the founder parent IDs.  

To use this option, the only input argument that is required is the `ped` argument in `magic.eval`.  

&nbsp;  

### Available Modifications {#S5.2}
In addition to the few input arguments for `magic.eval` described previously, there are 15 additional arguments that can be used to modify the design.  

&nbsp;  

#### Mod - reps {#S5.2.1}
`reps` is an important argument in `magic.eval` as it determines the number of replicates (seeds) to keep from each biological cross. If `reps` is not supplied, `magic.eval` will automatically assume no replications at any generation. `reps` has to be provided as a vector of length $log_2n$, with each element of the vector represent the number of replicates to keep at 2-way, 4-way, ..., n-way crosses. For example, if `n=8`, `reps=c(1,1,2)` means that 2 replicates per 8-way cross are kept. In the same example, `reps=c(2,1,1)` is meaningless in practice because the replicates of each 2-way cross are the same.  

Here are three pedigrees showing the effects of different `reps` in a single funnel for `n=8`.  

```{r echo=F, fig.width=10, fig.height=3}
df1.a <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 2.5, 6.5, 4.25, 4.75),
                    y=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5, 0, 0),
                    type="reps=c(1,1,2)")
df1.b <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 2.25, 2.75, 6.25, 6.75, 4.0, 5.0),
                    y=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5, 1.5, 1.5, 0, 0),
                    type="reps=c(1,2,1)")
df1.c <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 2.25, 2.75, 6.25, 6.75, 3.5, 4.0, 5.0, 5.5),
                    y=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5, 1.5, 1.5, 0, 0, 0, 0),
                    type="reps=c(1,2,2)")
df1 <- rbind(df1.a, df1.b, df1.c)

df2.a <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 2.75, 6.75),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 2.75, 2.75, 6.75, 6.75, 4.75, 4.75),
                    y1=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5),
                    y2=c(3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 2.0, 2.0, 2.0, 2.0, 0.5, 0.5),
                    type="reps=c(1,1,2)")
df2.b <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 2.5, 6.5, 3.0, 7.0),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 2.75, 2.75, 6.75, 6.75, 4.25, 4.25, 5.25, 5.25),
                    y1=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5, 1.5, 1.5),
                    y2=c(3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 2.0, 2.0, 2.0, 2.0, 0.5, 0.5, 0.5, 0.5),
                    type="reps=c(1,2,1)")
df2.c <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 2.5, 6.5, 3.0, 7.0),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 2.75, 2.75, 6.75, 6.75, 4.0, 4.0, 5.5, 5.5),
                    y1=c(4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 4.5, 3.0, 3.0, 3.0, 3.0, 1.5, 1.5, 1.5, 1.5),
                    y2=c(3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 3.5, 2.0, 2.0, 2.0, 2.0, 0.5, 0.5, 0.5, 0.5),
                    type="reps=c(1,2,2)")
df2 <- rbind(df2.a, df2.b, df2.c)


ggplot2::ggplot() +
  ggplot2::geom_rect(data=df1, ggplot2::aes(xmin=x, xmax=x+0.5, ymin=y, ymax=y+0.5), fill=NA, color="#555555") +
  ggplot2::geom_segment(data=df2, ggplot2::aes(x=x1, xend=x2, y=y1, yend=y2), color="#AAAAAA") +
  ggplot2::coord_fixed(ratio=1) +
  ggplot2::facet_wrap(ggplot2::vars(type), nrow=1) +
  ggplot2::annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, fill=NA, color="#DDDDDD") +
  ggplot2::theme(strip.text=ggplot2::element_text(hjust=0)) +
  ggplot2::theme(panel.grid=ggplot2::element_blank()) +
  ggplot2::theme(panel.background=ggplot2::element_blank()) +
  ggplot2::theme(axis.title=ggplot2::element_blank()) +
  ggplot2::theme(axis.text=ggplot2::element_blank()) +
  ggplot2::theme(axis.ticks=ggplot2::element_blank()) +
  ggplot2::theme(strip.background=ggplot2::element_blank())
```

In addition, if there is a need to include both directions of crosses (i.e. 1 x 2 and 2 x 1), elements of `reps` can be supplied as even number. For example, `reps=c(2,2,2)` would ensure both cross directions are included in each crossing generation. As mentioned previously, the directions of crosses do not matter in our simulation and the only consequence is that the RIL population size increases.  

&nbsp;  

#### Mod - self {#S5.2.2}
`self` is another important argument in `magic.eval` as it determines the number of selfing generations after every cross. If `self` is not supplied, `magic.eval` will assume no selfing at all. Similar to `reps`, `self` is a vector of length $log_2n$. In the common practice, `self` is only used in the single-seed descent (SSD) process after n-way crosses have been done. Using `n=8` as an example again, `self=c(0,0,3)` represents no selfing after two-way crosses, no selfing after four-way crosses, and three generations of selfing after eight-way crosses.  

Below are three pedigrees with different `self` for `n=8`.  

```{r echo=F, fig.width=10, fig.height=6}
df1.a <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 2.5, 6.5, 4.5, 4.5, 4.5, 4.5),
                    y=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 7.5, 6.0, 4.5, 3.0),
                    type="self=c(0,0,3)")
df1.b <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 2.5, 6.5, 2.5, 6.5, 4.5, 4.5, 4.5, 4.5),
                    y=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 7.5, 7.5, 6.0, 4.5, 3.0, 1.5),
                    type="self=c(0,1,3)")
df1.c <- data.frame(x=c(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 1.5, 3.5, 5.5, 7.5, 1.5, 3.5, 5.5, 7.5, 2.5, 6.5, 2.5, 6.5, 4.5, 4.5, 4.5, 4.5),
                    y=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 9.0, 9.0, 7.5, 7.5, 6.0, 6.0, 4.5, 3.0, 1.5, 0),
                    type="self=c(1,1,3)")
df1 <- rbind(df1.a, df1.b, df1.c)

df2.a <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 2.75, 6.75, 4.75, 4.75, 4.75),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 2.75, 2.75, 6.75, 6.75, 4.75, 4.75, 4.75, 4.75, 4.75),
                    y1=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 7.5, 6.0, 4.5),
                    y2=c(11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 9.5, 9.5, 9.5, 9.5, 8.0, 8.0, 6.5, 5.0, 3.5),
                    type="self=c(0,0,3)")
df2.b <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 2.75, 6.75, 2.75, 6.75, 4.75, 4.75, 4.75),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 2.75, 2.75, 6.75, 6.75, 2.75, 6.75, 4.75, 4.75, 4.75, 4.75, 4.75),
                    y1=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 7.5, 7.5, 6.0, 4.5, 3.0),
                    y2=c(11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 9.5, 9.5, 9.5, 9.5, 8.0, 8.0, 6.5, 6.5, 5.0, 3.5, 2.0),
                    type="self=c(0,1,3)")
df2.c <- data.frame(x1=c(1.25, 2.25, 3.25, 4.25, 5.25, 6.25, 7.25, 8.25, 1.75, 3.75, 5.75, 7.75, 1.75, 3.75, 5.75, 7.75, 2.75, 6.75, 2.75, 6.75, 4.75, 4.75, 4.75),
                    x2=c(1.75, 1.75, 3.75, 3.75, 5.75, 5.75, 7.75, 7.75, 1.75, 3.75, 5.75, 7.75, 2.75, 2.75, 6.75, 6.75, 2.75, 6.75, 4.75, 4.75, 4.75, 4.75, 4.75),
                    y1=c(12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 10.5, 10.5, 10.5, 10.5, 9.0, 9.0, 9.0, 9.0, 7.5, 7.5, 6.0, 6.0, 4.5, 3.0, 1.5),
                    y2=c(11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 11.0, 9.5, 9.5, 9.5, 9.5, 8.0, 8.0, 8.0, 8.0, 6.5, 6.5, 5.0, 5.0, 3.5, 2.0, 0.5),
                    type="self=c(1,1,3)")
df2 <- rbind(df2.a, df2.b, df2.c)


ggplot2::ggplot() +
  ggplot2::geom_rect(data=df1, ggplot2::aes(xmin=x, xmax=x+0.5, ymin=y, ymax=y+0.5), fill=NA, color="#555555") +
  ggplot2::geom_segment(data=df2, ggplot2::aes(x=x1, xend=x2, y=y1, yend=y2), color="#AAAAAA") +
  ggplot2::coord_fixed(ratio=1) +
  ggplot2::facet_wrap(ggplot2::vars(type), nrow=1) +
  ggplot2::annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, fill=NA, color="#DDDDDD") +
  ggplot2::theme(strip.text=ggplot2::element_text(hjust=0)) +
  ggplot2::theme(panel.grid=ggplot2::element_blank()) +
  ggplot2::theme(panel.background=ggplot2::element_blank()) +
  ggplot2::theme(axis.title=ggplot2::element_blank()) +
  ggplot2::theme(axis.text=ggplot2::element_blank()) +
  ggplot2::theme(axis.ticks=ggplot2::element_blank()) +
  ggplot2::theme(strip.background=ggplot2::element_blank())
```

&nbsp;  

#### Mod - inbred {#S5.2.3}
The default in `magic.eval` is `inbred=T` since we assume that the founders are inbred. Although the use of non-inbred founders in MAGIC population has not been very common, we do provide an option for non-inbred founders by setting `inbred=F`.  
The major consequence in `inbred=F` is how the 2-way crosses are handled. If the founders are inbred, then the 2-way crosses between the same founder pairs are all equivalent and so only one is needed for the subsequent 4-way crosses. But, if the founders are not inbred, then the 2-way crosses between the same founder pairs are no longer the same and so each unique individual (seed) is needed for the subsequent 4-way crosses. For example, we have two 4-way crosses here: (1 x 2) x (3 x 4) and (1 x 2) x (5 x 8). If the founders are inbred, we can just use the same (1 x 2) plant for both 4-way crosses. But if the founders are non-inbred, then we need to use two different (1 x 2) plants for each of the 4-way crosses because the (1 x 2) plants are all segregating differently.  

Another consequence of `inbred=F` is how the founder alleles are tracked during simulation. With inbred founders, we have only `n` founder alleles but with non-inbred founders, we maintain `2*n` founder alleles with two distinct alleles for each founder.  

Just a note for caution, `inbred=F` has not been tested extensively so there may still be bugs in the codes. Please let us know if there is any issue with this setting.  

&nbsp;  

#### Mod - balanced {#S5.2.4}
The `balanced` argument in `magic.eval` is a logical indicator of whether to use a balanced or unbalanced MAGIC design. A balanced design is defined as a design where all the funnels have equal representation of founders and founder crosses. An example of how a balanced design should look is shown in [Partial Design](#S5.1.2). A full design is always balanced, partial and NP2 designs can be either balanced or unbalanced, and a basic design is always unbalanced. Below is a figure and table to illustrate why a basic design is always unbalanced.  

```{r echo=F, fig.width=3, fig.height=3}
df1 <- data.frame(x=c(1, 2, 3, 4, 1.5, 3.5, 2.5),
                  y=c(5, 5, 5, 5, 3, 3, 1),
                  label=c("1", "2", "3", "4", "12", "34", "1234"))
df2 <- data.frame(x1=c(1, 2, 3, 4, 1.5, 3.5),
                  x2=c(1.5, 1.5, 3.5, 3.5, 2.5, 2.5),
                  y1=c(4.8, 4.8, 4.8, 4.8, 2.8, 2.8),
                  y2=c(3.2, 3.2, 3.2, 3.2, 1.2, 1.2))
ggplot2::ggplot() +
  ggplot2::geom_text(data=df1, ggplot2::aes(x=x, y=y, label=label), size=5) +
  ggplot2::geom_segment(data=df2, ggplot2::aes(x=x1, xend=x2, y=y1, yend=y2), color="#AAAAAA") +
  ggplot2::annotate("rect", xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, fill=NA, color="#DDDDDD") +
  ggplot2::theme(strip.text=ggplot2::element_text(hjust=0, size=15)) +
  ggplot2::theme(panel.grid=ggplot2::element_blank()) +
  ggplot2::theme(panel.background=ggplot2::element_blank()) +
  ggplot2::theme(axis.title=ggplot2::element_blank()) +
  ggplot2::theme(axis.text=ggplot2::element_blank()) +
  ggplot2::theme(axis.ticks=ggplot2::element_blank()) +
  ggplot2::theme(strip.background=ggplot2::element_blank())
```

```{r echo=F}
df <- data.frame(founder_pair=do.call(paste, c(data.frame(t(combn(4,2))), sep="-")),
                 two_way=c(1,0,0,0,0,1),
                 four_way=c(0,1,1,1,1,0))
df <- kableExtra::kable_styling(kableExtra::kbl(df), bootstrap_options="striped", full_width=F, position="left")
kableExtra::footnote(df, 
                     general="Founder pairs at 2-way and 4-way crosses are not equally represented.",
                     footnote_as_chunk=T)
```

&nbsp;  

#### Mod - minimize {#S5.2.5}
`minimize` is an argument for minimizing number of crosses and plants. Conventionally, under `minimize=F`, in making multiple same eight-way crosses, different four-way individuals are needed to maximize haplotype diversity. However, under `minimize=T`, the same eight-way crosses are made using the same four-way individuals. This is relevant in `n` equal to 16 or larger for balanced design with multiple funnel sets, as some eight-way individuals may repeat.  

In terms of minimizing plants, here is an example with `n=8` where we have two funnels: ((1 x 2) x (3 x 4)) x ((5 x 6) x (7 x 8)) and ((1 x 2) x (3 x 4)) x ((5 x 7) x (6 x 8)). Normally, we require two different ((1 x 2) x (3 x 4)) individuals to maximize haplotype diversity. If `minimize=T`, then the same ((1 x 2) x (3 x 4)) individual would be used to make the eight-way crosses.  

Generally, there is little incentive to use `minimize=T`, but it is provided as an option in case there is a need for it.  

&nbsp;  

#### Mod - n.try {#S5.2.6}
`n.try` is an argument in `magic.eval` that is only used for finding partial balanced design. By default, `n.try` is set to 1000 and that should suffice unless there is a rare issue in finding partial balanced design.  

&nbsp;  

#### Mod - addx {#S5.2.7}
`addx` is an argument in `magic.eval` that adds an extra crossing generation after the final n-way crosses. `addx` is `NULL` by default, and it is available as either `1` or `2`. For `addx=1`, this only works with a basic design as it splits the n-way crosses into two pools and make all possible crosses between these two pools. Since this requires two pools of n-way crosses, the `reps` must be provided such that even number of n-way crosses are produced. For `addx=2`, this works with any design although it is only recommended for basic or small partial design as this option makes all possible crosses among the n-way individuals (random mating). For `k` available n-way crosses, this would lead to $k!/(2!*(k-2)!)$ extra crosses.  

&nbsp;  

#### Mod - repx {#S5.2.8}
`repx` is an argument in `magic.eval` that follows if `addx` is set to either 1 or 2. Like its counterpart `reps`, `repx` is simply an integer indicating how many replicates (seeds) per extra cross to keep.  

&nbsp;  

#### Mod - selfx {#S5.2.9}
`selfx` is an argument in `magic.eval` that follows if `addx` is set to either 1 or 2. Like its counterpart `self`, `selfx` is simply an integer indicating how many selfing generations to include after the extra cross.  

&nbsp;  

#### Mod - marker.dist {#S5.2.10}
`marker.dist`, as its name suggests, determines the marker distance in the simulated population. By default, this is set to 0.01 Morgan (1 centiMorgan).  

&nbsp;  

#### Mod - chr.len {#S5.2.11}
`chr.len` is an important argument as it provides the number of chromosomes and genetic lengths of each chromosome to the simulation. So, `chr.len` should be supplied as a vector of genetic lengths in the unit of Morgans. For example, `chr.len=c(2.45, 2.89, 1.53)` would mean that this simulated species has three chromosomes of 2.45, 2.89 and 1.53 Morgans respectively.  

&nbsp;  

#### Mod - n.sim {#S5.2.12}
`n.sim` determines the number of simulations to run. It is best to start off with `n.sim=1`, which is also the default, to ensure that the design is working fine before committing into a longer run time with higher `n.sim`. Once everything is working fine, users may choose `n.sim=100` or some other values. The design (crossing scheme) is generated once regardless of `n.sim`, while the population is simulated over `n.sim` times.  

&nbsp;  

#### Mod - hap.int {#S5.2.13}
`hap.int` refers to haplotype interval, which is the interval in Morgans to look for recombinant haplotypes generated from the MAGIC design. By default, `hap.int` is set to 0.05 Morgan and that tells `magic.eval` to compute the count of all possible recombinant haplotypes among the founder pairs within that said interval.  

&nbsp;  

#### Mod - n.hap {#S5.2.14}
`n.hap` indicates the number of haploid marker data to extract from the MAGIC RILs for results. By default, `n.hap` is set to 1. If the RILs fully inbred, then there is no difference between `n.hap=1` and `n.hap=2`. That said, `n.hap=1` should be sufficient as long as there are a few generations of single-seed descent (SSD).  

&nbsp;  

#### Mod - keep {#S5.2.15}
`keep` decides if the simulated marker data is exported or not. By default, this is not exported because the data can be large and rarely useful. If `keep=T`, `magic.eval` will export the marker data from all simulations into a "csv" file. If users choose to use this option, please keep `n.sim=1` or small to prevent unneccessary slow down in processing.  

&nbsp;  

### Results Visualization {#S5.3}
One or more results from `magic.eval` can be visualized in several plots and tables. The relevant functions are `magic.ped2plot`, `magic.plot` and `magic.summary`. The first function, `magic.ped2plot` converts a pedigree matrix into an interactive plot (exported as an external HTML file). Two other functions, `magic.plot` and `magic.summary` perform the same results comparisons except former displays the output as plots and the latter displays the output as tables. Note that `magic.plot` and `magic.summary` require a list of one or more designs that were created and tested in `magic.eval`, and these designs must have the same `marker.dist`, `chr.len`, `n.sim`, `hap.int` and `n.hap` otherwise the comparison is meaningless.  

&nbsp;  

#### Plot - Pedigree {#S5.3.1}
The `magic.ped2plot` function has two required arguments, `ped` and `filename`, as well as four optional arguments, `basic`, `show.partial`, `w2h.ratio` and `force.option`. The `ped` argument can take pedigree generated from `magic.eval`, which is the first object in the list of outputs from `magic.eval`. Similarly, the `ped` argument can also take any custom pedigree, as long as it conforms to the same standard as the pedigree required for `ped` input in `magic.eval` (see [Pedigree](#S5.1.5)). The `filename` argument is simply a character string that users wish to save the pedigree plot as. Please refrain from putting a full directory in the `filename` argument, and instead, it is better to use `setwd()` to set the working directory. This ensures that the HTML file is saved in a self-contained format.  

As the name suggests, the optional argument `basic` should be set to `TRUE` only for pedigree created from basic design. `show.partial=T` should only be used for pedigree created from either full or partial balanced designs, as it displays the pedigree for only a single partial balanced funnel set. This is just a nicer way to show the subset of a complicated pedigree. `w2h.ratio` is 2 by default, and it is simply the width-to-height ratio of the pedigree plot. `force.option` is `FALSE` by default, and if it set to `TRUE`, it will create a simpler and less decorated pedigree plot.  

&nbsp;  

#### Plot - Interval {#S5.3.2}
The `magic.plot` function has four arguments, `input`, `display`, `fpair`, `chr.names` and `annotate`. The `input` argument is a list of one or more outputs from `magic.eval`. The `display` argument is a character string of either `"interval"` or `"whole"`. The `fpair` argument is a matrix of two columns and is only required when `display="interval"` as it specifies which recombinant haplotypes to display. For example, with `n=8`, setting `fpair=cbind(c(1,1,3,5), c(2,4,6,4))` would show only "1-2", "1-4", "3-6" and "5-4" recombinant haplotypes in the output. The `chr.names` argument is a vector of chromosome names, for example, `chr.names=c("1A","1B","1D")`. The `annotate` argument is a logical indicator of whether to annotate Plot C when `display="whole"`.  

For `display="interval"`, a plot with 3 panels (labelled as A, B, C) will be created.  

1. Plot A shows the proportions of total recombinant haplotypes within the specified `hap.int`.
2. Plot B shows the counts of unique recombinant haplotypes within `hap.int`. Note that this maxes out at $n^2-n$.
3. Plot C shows the proportions of each recombinant haplotype within `hap.int`.

High mean and low variance are better for all of these plots, and "evenness" across each recombinant haplotype in Plot C is also important.  

&nbsp;  

#### Plot - Whole {#S5.3.3}
For `display="whole"`, a plot with 3 panels (labeled as A, B, C) will be created.  

1. Plot A shows the mean proportions of each founder genome.
2. Plot B shows the mean counts of unique founder genome in each chromosome.
3. Plot C shows the LOESS regression of the mean counts of non-recombinant segments of various lengths in each chromosome.

For Plot A, "evenness" across all founders is better. For Plot B, higher counts (right-biased) is better. For Plot C, higher counts of short segments (left-biased) is better.  

&nbsp;  

#### Summary Tables {#S5.3.4}
The `magic.summary` function presents a summary information for all the designs compared, as well as the same comparisons as `magic.plot`. The latter output is provided as an alternative to `magic.plot`. In the case with many designs being compared, the designs shown in plots can be challenging to distinguish especially for users with color-blindness.  

The only argument needed for `magic.summary` is `input`, which is a list of one or more outputs from `magic.eval`.  

&nbsp;  

### Miscellaneous Notes
To be added.  

## Examples {#S6}
For all the examples here, we will use a fictitious species with 5 chromosomes. Genetic lengths of these chromosomes are 3.37, 2.89, 2.50, 2.11, 1.94 Morgans.  

&nbsp;  

##### 4 founders + full design + reps + self (120 RILs, 3 funnels)
```{r eval=F}
mpop.1 <- magicdesign::magic.eval(n=4,
                                  m=1,
                                  reps=c(1,40),
                                  self=c(0,4),
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 4 founders + full design + reps + self + addx (108 RILs, 3 funnels)
```{r eval=F}
mpop.2 <- magicdesign::magic.eval(n=4,
                                  m=1,
                                  reps=c(1,3),
                                  self=c(0,0),
                                  addx=2,
                                  repx=3,
                                  selfx=4,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 4 founders + basic design + reps + self + addx (100 RILs, 1 funnel)
```{r eval=F}
mpop.3 <- magicdesign::magic.eval(n=4,
                                  m=0,
                                  reps=c(1,10),
                                  self=c(0,0),
                                  addx=1,
                                  repx=4,
                                  selfx=4,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 4 founders + custom pedigree (120 RILs, 3 funnels, different reps for each funnel)
```{r eval=F}
custom.ped <- cbind(c(1:610),
                    c(0,0,0,0,1,1,1,2,2,3,rep(5,50),rep(6,40),rep(7,30),11:490),
                    c(0,0,0,0,2,3,4,3,4,4,rep(10,50),rep(9,40),rep(8,30),11:490),
                    c(0,0,0,0,1,1,1,1,1,1,rep(2,120),rep(3,120),rep(4,120),rep(5,120),rep(6,120)))
mpop.4 <- magicdesign::magic.eval(ped=custom.ped,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 8 founders + full design + reps + self (630 RILs, 315 funnels)
```{r eval=F}
mpop.5 <- magicdesign::magic.eval(n=8,
                                  m=45,
                                  reps=c(1,1,2),
                                  self=c(0,0,4),
                                  balanced=T,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 8 founders + partial design + balanced + reps + self (588 RILs, 49 funnels)
```{r eval=F}
mpop.6 <- magicdesign::magic.eval(n=8,
                                  m=7,
                                  reps=c(1,3,4),
                                  self=c(0,0,4),
                                  balanced=T,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 8 founders + partial design + unbalanced + reps + self (588 RILs, 49 funnels)
```{r eval=F}
mpop.7 <- magicdesign::magic.eval(n=8,
                                  m=49,
                                  reps=c(1,3,4),
                                  self=c(0,0,4),
                                  balanced=F,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 8 founders + basic design + reps + self + addx (576 RILs, 1 funnel)
```{r eval=F}
mpop.8 <- magicdesign::magic.eval(n=8,
                                  m=0,
                                  reps=c(1,6,4),
                                  self=c(0,0,0),
                                  addx=1,
                                  repx=4,
                                  selfx=4,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 16 founders + partial design + balanced + reps + self (600 RILs, 75 funnels)
```{r eval=F}
mpop.9 <- magicdesign::magic.eval(n=16,
                                  m=5,
                                  reps=c(1,2,2,2),
                                  self=c(0,0,0,4),
                                  balanced=T,
                                  chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                  n.sim=100)
```

&nbsp;  

##### 16 founders + partial design + unbalanced + reps + self (600 RILs, 75 funnels)
```{r eval=F}
mpop.10 <- magicdesign::magic.eval(n=16,
                                   m=75,
                                   reps=c(1,2,2,2),
                                   self=c(0,0,0,4),
                                   balanced=F,
                                   chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                   n.sim=100)
```

&nbsp;  

##### 16 founders + basic design + reps + self + addx (600 RILs, 1 funnel)
```{r eval=F}
mpop.11 <- magicdesign::magic.eval(n=16,
                                   m=0,
                                   reps=c(1,4,2,2),
                                   self=c(0,0,0,0),
                                   addx=2,
                                   repx=5,
                                   selfx=4,
                                   chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                   n.sim=100)
```

&nbsp;  

##### 6 founders + NP2 design + balanced + reps + self (480 RILs, 60 funnels)
```{r eval=F}
mpop.12 <- magicdesign::magic.eval(n=6,
                                   m=20,
                                   reps=c(1,2,4),
                                   self=c(0,0,4),
                                   balanced=T,
                                   chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                   n.sim=100)
```

&nbsp;  

##### 6 founders + NP2 design + balanced + reps + self (480 RILs, 60 funnels)
```{r eval=F}
mpop.13 <- magicdesign::magic.eval(n=6,
                                   m=60,
                                   reps=c(1,2,4),
                                   self=c(0,0,4),
                                   balanced=F,
                                   chr.len=c(3.37, 2.89, 2.50, 2.11, 1.94),
                                   n.sim=100)
```

&nbsp;  

##### Displaying results for some of the examples.
We will display the results for all the 4-founder examples.  

Here are the `R` scripts required for plotting the pedigrees. Note that the pedigree plots are saved as external HTML files.  

```{r eval=F}
magicdesign::magic.ped2plot(ped=mpop.1$ped, filename="mpop1")
magicdesign::magic.ped2plot(ped=mpop.2$ped, filename="mpop2")
magicdesign::magic.ped2plot(ped=mpop.3$ped, filename="mpop3", basic=T)
magicdesign::magic.ped2plot(ped=mpop.4$ped, filename="mpop4")
```

Now, we can compare the results for these four different designs. We will start by plotting using the `display="interval"` option.  

```{r fig.width=10}
load("C:/Users/cjyan/Box Sync/MAGIC16/v20210204/github/misc/example_mpop1_4.RData")
magicdesign::magic.plot(input=list(mpop.1, mpop.2, mpop.3, mpop.4),
                        display="interval")
```

Next, we will plot using the `display="whole"` option.  

```{r fig.width=10, fig.height=10}
magicdesign::magic.plot(input=list(mpop.1, mpop.2, mpop.3, mpop.4),
                        display="whole")
```

Lastly, we can look at some summary information of each design.  
```{r}
out.mpop <- magicdesign::magic.summary(input=list(mpop.1, mpop.2, mpop.3, mpop.4))
```

## Final remarks
Please feel free to email CJ (cyang@sruc.ac.uk) if you have any issue or question on how to use `magicdesign`.  


